"""
Code generation service using Google Gemini AI.
"""
import os
import re
import json
from typing import List
import google.generativeai as genai

from app.models import GeneratedFile


def check_gemini_health() -> bool:
    """Check if Gemini API is configured."""
    api_key = os.getenv("GEMINI_API_KEY")
    return api_key is not None and api_key.strip() != ""


async def generate_code(prompt: str, model: str = "gemini-2.5-flash") -> List[GeneratedFile]:
    """
    Generate code files using Google Gemini AI.

    Args:
        prompt: User prompt describing what to generate
        model: Gemini model to use

    Returns:
        List of GeneratedFile objects with path and content

    Raises:
        ValueError: If API key is not configured
        Exception: If generation fails
    """
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY environment variable not set")

    # Configure Gemini
    genai.configure(api_key=api_key)

    # Create the model
    model_instance = genai.GenerativeModel(model)

    # Craft the system prompt
    system_prompt = """You are an expert web developer. Generate complete, production-ready HTML/CSS/JS code.

IMPORTANT: Return your response as a JSON array of files. Each file should have:
- "path": relative file path (e.g., "index.html", "css/styles.css", "js/app.js")
- "content": the complete file contents

Example format:
```json
[
  {
    "path": "index.html",
    "content": "<!DOCTYPE html>\\n<html>...</html>"
  },
  {
    "path": "css/styles.css",
    "content": "body { margin: 0; }..."
  }
]
```

Generate clean, modern, responsive code. Use semantic HTML, proper CSS styling, and vanilla JavaScript.
"""

    # Combine system prompt with user prompt
    full_prompt = f"{system_prompt}\n\nUser request: {prompt}"

    # Generate content
    response = model_instance.generate_content(full_prompt)

    if not response or not response.text:
        raise Exception("Empty response from AI model")

    # Extract JSON from response
    text = response.text.strip()

    # Try to extract JSON from code blocks
    json_match = re.search(r'```(?:json)?\s*(\[[\s\S]*?\])\s*```', text)
    if json_match:
        json_text = json_match.group(1)
    else:
        # Try to find JSON array directly
        json_match = re.search(r'(\[[\s\S]*\])', text)
        if json_match:
            json_text = json_match.group(1)
        else:
            # Fallback: treat entire response as single HTML file
            return [
                GeneratedFile(
                    path="index.html",
                    content=text
                )
            ]

    try:
        files_data = json.loads(json_text)
    except json.JSONDecodeError as e:
        raise Exception(f"Failed to parse AI response as JSON: {str(e)}")

    # Convert to GeneratedFile objects
    files = []
    for file_data in files_data:
        if not isinstance(file_data, dict):
            continue

        path = file_data.get("path", "").strip()
        content = file_data.get("content", "")

        if not path:
            continue

        # Validate path (no parent directory traversal)
        if ".." in path or path.startswith("/"):
            continue

        files.append(GeneratedFile(path=path, content=content))

    if not files:
        raise Exception("No valid files generated by AI")

    return files

